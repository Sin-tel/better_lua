#intrinsic
array.push: fn([T], T) -> () = #"
function(arr, e)
	arr[arr.n] = e
	arr.n = arr.n + 1
end
"#

#intrinsic
array.len: fn([T]) -> int = #"
function(arr)
	return arr.n
end
"#

#intrinsic
array.pop: fn([T]) -> T = #"
function(arr)
	assert(arr.n > 0, "empty array")
	arr.n = arr.n - 1
	local item = arr[arr.n]
	arr[arr.n] = nil
	return item
end
"#

#intrinsic
array.first: fn([T]) -> T = #"
function(arr)
	assert(arr.n > 0, "empty array")
	return arr[0]
end
"#

#intrinsic
array.last: fn([T]) -> T = #"
function(arr)
	assert(arr.n > 0, "empty array")
	return arr[arr.n-1]
end
"#

from iter import range

fn array.__eq(a: [T], b: [T]) -> bool {
	let eq = true
	if a.len() != b.len() {
		return false
	}
	// TODO: zip(a, b)
	for i in range(a.len()) {
		if a[i] != b[i] {
			return false
		}
	}
	return eq
}

// fn array.to_str(a: [T]) -> str {
// 	let s = "["
// 	for k in a.iter() {
// 		s ..= k as str .. ", "
// 	}
// 	s ..= "]"
// 	return s
// }
